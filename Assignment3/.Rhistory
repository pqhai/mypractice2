sapply(split(iris, iris$Species), mean)
sapply(split(iris, iris$Species), mean)
tapply(iris$Sepal.Length, iris$Species, mean)
mean(iris$Sepal.Length[iris$Species]=='Virginica')
mean(iris$Sepal.Length [iris$Species]=='Virginica')
mean(iris$Sepal.Length [iris$Species=="virginica"],na.rm=TRUE)
?mean
mean(iris$Sepal.Length [iris$Species=="virginica"], na.rm=TRUE)
mean(iris$Sepal.Length [iris$Species=="virginica"], na.rm=TRUE)
split(iris, iris$Species)
mean(iris$Species$virginica)
mean(iris$virginica$Species)
mean(iris$virginica$Sepal.Length)
a <- iris$Species
mean(a$virginica$Sepal.Length)
> A <-split (iris, iris $ Species)
$ Setosa
......
$ Versicolor
......
$ Virginica
......
> Mean (a $ virginica $ Sepal.Length
?tapply
?lapply
?tapply
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
?inverse.gaussian
?inverse
??inverse
?solve
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
makeCacheMatrix <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setInverse <- function(Inverse) m <<- Inverser
getInverse <- function() m
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
m <- x$getInverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- Solve(data, ...)
x$setInverse(m)
m
}
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
my_matrix$getInverse()
cacheSolve(my_matrix)
cacheSolve(my_matrix)
?solve
cacheSolve(my_matrix)
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setInverse <- function(Inverse) m <<- Inverser
getInverse <- function() m
list(set = set, get = get,
setInverse = setInverse,
getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x
m <- x$getInverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- Solve(data, ...)
x$setInverse(m)
m
}
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
my_matrix$getInverse()
cacheSolve(my_matrix)
## Caching the Inverse of a Matrix:
## Matrix inversion is usually a costly computation and there may be some
## benefit to caching the inverse of a matrix rather than compute it repeatedly.
## Below are a pair of functions that are used to create a special object that
## stores a matrix and caches its inverse.
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## This function computes the inverse of the special "matrix" created by
## makeCacheMatrix above. If the inverse has already been calculated (and the
## matrix has not changed), then it should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
cacheSolve(my_matrix)
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
}
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$getinverse()
my_matrix
my_matrix$get()
cacheSolve(my_matrix)
cacheSolve(my_matrix)
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
cacheSolve(my_matrix)
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
cacheSolve(my_matrix)
## Caching the Inverse of a Matrix:
## Matrix inversion is usually a costly computation and there may be some
## benefit to caching the inverse of a matrix rather than compute it repeatedly.
## Below are a pair of functions that are used to create a special object that
## stores a matrix and caches its inverse.
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## This function computes the inverse of the special "matrix" created by
## makeCacheMatrix above. If the inverse has already been calculated (and the
## matrix has not changed), then it should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
## Test
my_matrix <- makeCacheMatrix(matrix(1:9, 3, 3))
my_matrix$get()
cacheSolve(my_matrix)
## Caching the Inverse of a Matrix:
## Matrix inversion is usually a costly computation and there may be some
## benefit to caching the inverse of a matrix rather than compute it repeatedly.
## Below are a pair of functions that are used to create a special object that
## stores a matrix and caches its inverse.
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## This function computes the inverse of the special "matrix" created by
## makeCacheMatrix above. If the inverse has already been calculated (and the
## matrix has not changed), then it should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
## Test
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
cacheSolve(my_matrix)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
## Test
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
cacheSolve(my_matrix)
## These functions will return an inverse matrix, using caches to store and retrieve the original and its inverse
## The makeCacheMatrix function generates an R object that stores a matrix and its inverse matrix
## It stores a list of functions (set, get, setinverse, getinverse) and data objects x and m
## x is the argument matrix and m is its inverse
makeCacheMatrix <- function(x = matrix()) {
# mackeCache Matrix creates an R object that stores a vector and its mean
# initialize the value m to store the cached inverse value
m <- NULL
# set will cache the input matrix x and will reinitialize m
set <- function(y) {
x <<- y
m <<- NULL
}
# get returns the cached matrix
get <- function() x
# setinverse caches m passed through cacheSolve
setinverse <- function(inverse) m <<- inverse
# getinverse returns cached m
getinverse <- function() m
#the makeCacheMatrix function finally returns a list of named functions
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function takes as argument the makeCacheMatrix object in order to
## retrieve the inverse matrix
cacheSolve <- function(x, ...) {
# Return the cached matrix value m and see if it stores any values
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
# store the input matrix in "data"
data <- x$get()
# calculate the inverse matrix using solve and assign it to "m"
m <- solve(data, ...)
# use setinverse to cache the value of m
x$setinverse(m)
#return the value of m (the inverse matrix)
m
}
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
cacheSolve(my_matrix)
libarary(swirl)
library(swirl)
swirl()
ls()
class(plants)
dim(plants)
nrow(plants)
ncol(plants)
object.size(plants)
names(plants)
head()
head(x)
head(plants)
head(plants, 10)
tail(plants)
tail(plants, 15)
summary(plants)
table(plants$Active_Growth_Period)
str(plants)
?sample
sample(1:6, 4, replace = TRUE)
sample(1:6, 4, replace = TRUE)
sample(1:20, 10, replace = FALSE)
sample(1:20, 10)
sample(letters, 26)
sample(LETTERS, 26)
LETTERS
sample(LETTERS)
flips <- c(0, 1)
flips <- sample(c(0,1), 100, replace = TRUE, prob = c(0.3, 0.7))
flips
sum(flips)
?rbinom
rbinom(1, size = 100, prob = 0.7)
flips2 <- sample(1, 100, replace = TRUE, prob = 0.7)
flips2 <- rbinom(1, 100, 0.7)
flips2 <- rbinom(100, 1, 0.7)
flips2
sum(flips2)
rnorm()
rnorm(100, 0, 1)
?rnorm
rnorm(10)
rnorm(10, 0, 2)
rnorm(10, 100, 25)
rpois(5, 10)
my_pois <- replicate(100, rpois(5, 10))
my_pois
cm <- colMeans(my_pois)
hist(cm)
data(cars)
help(cars)
head(cars)
plot(cars)
?plot
plot(speed, dist)
plot(x, y)
plot(x = cars$speed, y = cars$dist)
plot(x= cars$dist, y= cars$speed)
plot(x = "speed", y = "dist")
plot(x = "speed", y = "dist")
plot(x = "speed", y = "dist")
x-axis = "speed"
x-axis <- "speed"
plot("speed", "dist")
plot(x = cars$speed, y = cars$dist, xlab = "Speed")
plot(x = cars$speed, y = cars$dist, ylab = "Stopping Distance")
plot(x = cars$speed, y = cars$dist, xlab = "Speed", ylab = "Stopping Distance")
plot(cars, main = "My plot")
plot(cars, main = "My plot")
plot(cars, main = "My Plot")
plot(cars, sub = "My Plot Subtitle")
plot(cars, col = 2)
plot(cars, xlim = c(10, 15))
plot(cars, pch = 2)
data(mtcars)
?boxplot
boxplot(mtcars, mpg ~ cyl)
boxplot(formula = mpg ~ cyl, data = mtcars)
hist(mtcars)
hist.default(mtcars)
hist(mtcars$mpg)
set.seed(1)
set.seed(1)
rpois(5, 2)
set.seed(10)
x <- rep(0:1, each = 5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
#|------------------------------------------------------------------------------------------|
#|                                I N I T I A L I Z A T I O N                               |
#|------------------------------------------------------------------------------------------|
#| YOU HAVE TO CHECK YOUR WORKING DIRECTORY FIRST!!!!!
Init <- function(fileStr, workDirStr="C:/Users/Hai Pham/Desktop/mypractice2/Assignment3")
{
setwd(workDirStr)
retDfr <- read.csv(fileStr, colClasses = "character")
return(retDfr)
}
#|------------------------------------------------------------------------------------------|
#|                            I N T E R N A L   F U N C T I O N S                           |
#|------------------------------------------------------------------------------------------|
best <- function(stateChr, outcomeChr)
{
#--- Init loading outcome data
outcomeDfr <- Init("outcome-of-care-measures.csv")
#--- Coerce character into numeric
suppressWarnings( outcomeDfr[, 11] <- as.numeric(outcomeDfr[, 11]) )
suppressWarnings( outcomeDfr[, 17] <- as.numeric(outcomeDfr[, 17]) )
suppressWarnings( outcomeDfr[, 23] <- as.numeric(outcomeDfr[, 23]) )
#--- Create a data frame of freq by state
#       Remove row.names
tableDfr <- data.frame(State=names(tapply(outcomeDfr$State, outcomeDfr$State, length)),
Freq=tapply(outcomeDfr$State, outcomeDfr$State, length))
rownames(tableDfr) <- NULL
#--- Create a data frame of possible inputs and respective columns
inputDfr <- data.frame(Outcome=c("heart attack", "heart failure","pneumonia"), Col=c(11, 17, 23))
#--- Check that state and outcome are valid
if( nrow(tableDfr[tableDfr$State==stateChr,]) == 0 ) stop( "invalid state" )
if( nrow(inputDfr[inputDfr$Outcome==outcomeChr,]) == 0 ) stop( "invalid outcome" )
#--- Return hospital name in that state with lowest THIRTY(30)-day death rate
#       Create a data frame with given ONE (1) state
#       Determine the relevant row and column
stateDfr <- outcomeDfr[outcomeDfr$State==stateChr, ]
colNum <- inputDfr[inputDfr$Outcome==outcomeChr, 2]
rowNum <- which.min(stateDfr[, colNum])
return( stateDfr[rowNum, ]$Hospital.Name )
}
best("TX", "heart failure")
